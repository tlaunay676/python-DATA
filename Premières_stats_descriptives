#Moyenne espérance de vie, autres variables d'intérêt
import csv
#on met le fichier ou se trouve la variable d'intérêt dans le premier argument, le numéro de colonne (0 si c'est la première) où elle se trouve dans la deuxième
def moyenne(fichier_csv,numero_colonne):
    somme = 0.0
    nombre=0
    with open(fichier_csv, mode='r', encoding='utf-8') as fichier:
        lecteur_csv = csv.reader(fichier)
        next(lecteur_csv)  # Ignorer la première ligne (en-tête)
        for ligne in lecteur_csv:
            try:
                valeur = float(ligne[numero_colonne])  # Index 35 pour la colonne 36
                somme += valeur
                nombre= nombre+1
            except (ValueError, IndexError):
                print(f"Attention : une valeur non numérique ou une ligne incomplète a été ignorée : {ligne}")
    return somme/nombre

#Mediane variables d'intérêt
def mediane(fichier_csv,numero_colonne):
    
# Exemple d'utilisation
fichier = "WHO_SDG3_SELECT_COUNTRY_2025.csv"
resultat = moyenne(fichier,35)
print(f"La somme des valeurs de la colonne 36 (à partir de la ligne 2) est : {resultat}")

#code régression linéaire simple avec Y=a+b*log(X)
import numpy as np
import pandas as pd
import statsmodels.api as sm

# 1. Chargement
df = pd.read_csv('Table_complète.csv')

# --- ETAPE DE NETTOYAGE CRITIQUE ---

# A. On supprime les lignes vides dès le départ (NaN)
# Si une ligne n'a pas de PIB ou pas d'espérance de vie, on l'enlève
df = df.dropna(subset=['2021', 'Espérance de vie totale'])

# B. On ne garde que les PIB strictement positifs
# C'est OBLIGATOIRE pour le logarithme. log(0) = infini (erreur)
df = df[df['2021'] > 0]

# --- FIN DU NETTOYAGE ---

# 2. Création du Log
df['log_PIB'] = np.log(df['2021'])

# 3. Vérification ultime (au cas où des infinis traînent encore)
# On remplace les infinis par NaN et on les supprime
df.replace([np.inf, -np.inf], np.nan, inplace=True)
df = df.dropna(subset=['log_PIB', 'Espérance de vie totale'])

# 4. Définition des variables finales
Y = df['Espérance de vie totale']
X = df['log_PIB']

print(f"Nombre de lignes utilisées pour la régression : {len(df)}")

# 5. Régression
X_with_const = sm.add_constant(X)
modele = sm.OLS(Y, X_with_const)
resultats = modele.fit()

print(resultats.summary())

# --- 5. GRAPHIQUE (Optionnel pour vérifier visuellement) ---
plt.scatter(df['log_PIB'], df['Espérance de vie totale'], alpha=0.5, label='Données')
plt.plot(df['log_PIB'], resultats.predict(), color='red', label='Régression')
plt.xlabel('Log(PIB)')
plt.ylabel('Espérance de vie totale')
plt.legend()
plt.show()

#régression linéaire multiple: Y=a+b*log(X)+c*G
import numpy as np
import pandas as pd
import statsmodels.api as sm

# 1. Chargement
# Si tes décimales sont des virgules, ajoute decimal=',' dans la parenthèse
df = pd.read_csv('Table_complète.csv') 

# --- A MODIFIER SELON TON FICHIER ---
nom_colonne_Y = 'Espérance de vie totale'
nom_colonne_D = '2022'             # Variable qui sera passée en log
nom_colonne_G = 'Médecins pour 10k habitants'   # TA 2ème VARIABLE (ex: 'Education', 'Chomage')
# ------------------------------------

# 2. Nettoyage et Conversion (Pour les 3 variables)
cols_to_check = [nom_colonne_Y, nom_colonne_D, nom_colonne_G]

# On force tout en numérique
for col in cols_to_check:
    df[col] = pd.to_numeric(df[col], errors='coerce')

# On supprime les lignes vides (Si une seule des 3 valeurs manque, on supprime la ligne)
df = df.dropna(subset=cols_to_check)

# On filtre les valeurs <= 0 pour la variable qui va passer au Log (PIB)
df = df[df[nom_colonne_D] > 0]

# 3. Transformation des variables
df['log_PIB'] = np.log(df[nom_colonne_D]) # Ton D
# Si tu ne transformes pas G, on la garde telle quelle

# 4. Définition de Y et X (Multiple)
Y = df[nom_colonne_Y]

# C'est ICI que ça change : on sélectionne plusieurs colonnes avec des double crochets [[ ]]
X = df[['log_PIB', nom_colonne_G]] 

# 5. Ajout de la constante (le vecteur 1)
# X devient une matrice avec 3 colonnes : (1, log_PIB, G)
X_with_const = sm.add_constant(X)

# 6. Régression
modele = sm.OLS(Y, X_with_const)
resultats = modele.fit()

print(resultats.summary())