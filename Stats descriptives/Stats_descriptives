import csv
import os

def somme_colonne_espérance_de_vie(fichier_csv):
    # Vérifie si le fichier existe
    if not os.path.exists(fichier_csv):
        raise FileNotFoundError(f"Le fichier '{fichier_csv}' est introuvable. Vérifie le chemin.")

    somme = 0.0
    total = 0.0
    with open(fichier_csv, mode='r', encoding='utf-8') as fichier:
        lecteur_csv = csv.reader(fichier)
        next(lecteur_csv)  # Ignore la première ligne (en-tête)

        for i, ligne in enumerate(lecteur_csv, start=2):  # Commence à compter à partir de la ligne 2
            try:
                # Vérifie si la ligne a assez de colonnes
                if len(ligne) <= 35:
                    print(f"Attention : La ligne {i} est incomplète (moins de 36 colonnes). Valeur ignorée.")
                    continue

                # Convertit la valeur en float et l'ajoute à la somme
                valeur = float(ligne[35])
                somme += valeur
                total = total+1
            except ValueError:
                print(f"Attention : La valeur '{ligne[35]}' à la ligne {i} n'est pas un nombre. Valeur ignorée.")

    return (somme/total, total)

# Exemple d'utilisation avec le chemin mis à jour
try:
    fichier = "/home/onyxia/work/python-DATA/Données_OMS/WHO_SDG3_SELECT_COUNTRY_2025.csv"
    resultat = somme_colonne_espérance_de_vie(fichier)
    print(f"La somme des valeurs de la colonne 36 (à partir de la ligne 2) est : {resultat}")
except Exception as e:
    print(f"Erreur : {e}")

import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt

# 1. Charger les données (la table fusionnée)
file_path = 'WHO_SDG_GPW_SDG3_fusionne.csv'  # ou votre fichier sécurisé
df = pd.read_csv(file_path)

# --- CONFIGURATION DES VARIABLES ---
# Remplacez ces noms par les colonnes exactes de votre fichier
colonne_Y = 'Nom_de_votre_colonne_Y'  # La variable à prédire (ex: Espérance de vie)
colonne_D = 'Nom_de_votre_colonne_X'  # La variable explicative (ex: PIB, Dépenses santé)

print(f"Régression de '{colonne_Y}' sur '{colonne_D}'")

# 2. Nettoyage des données
# La régression ne supporte pas les valeurs manquantes (NaN)
data_reg = df[[colonne_Y, colonne_D]].dropna()

# Vérification qu'il reste des données
if len(data_reg) == 0:
    print("Erreur : Plus aucune donnée après suppression des valeurs manquantes.")
else:
    # 3. Préparation des variables
    Y = data_reg[colonne_Y]
    D = data_reg[colonne_D]
    
    # AJOUT DE LA CONSTANTE (C'est votre "1" dans X=(1,D))
    # Sans cela, la droite passerait forcément par 0 (l'origine)
    X = sm.add_constant(D) 

    # 4. Ajustement du modèle (OLS = Ordinary Least Squares)
    model = sm.OLS(Y, X)
    results = model.fit()

    # 5. Afficher le rapport statistique complet
    print(results.summary())

    # --- VISUALISATION ---
    plt.figure(figsize=(10, 6))
    
    # Nuage de points (Données réelles)
    plt.scatter(data_reg[colonne_D], data_reg[colonne_Y], alpha=0.5, label='Données observées')
    
    # Droite de régression (Prédictions)
    # On utilise les paramètres du modèle pour tracer la ligne
    plt.plot(data_reg[colonne_D], results.predict(X), color='red', linewidth=2, label='Droite de régression')
    
    plt.title(f'Régression Linéaire : {colonne_Y} vs {colonne_D}')
    plt.xlabel(colonne_D)
    plt.ylabel(colonne_Y)
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    
    # Sauvegarder le graphique
    plt.savefig('resultat_regression.png')
    print("\n✓ Graphique sauvegardé sous 'resultat_regression.png'")
    # plt.show() # Décommentez si vous exécutez cela dans un notebook Jupyter local
